<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ZAI OS - Professional Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            overflow: hidden;
            background: #000000;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Helvetica Neue', Arial, sans-serif;
            color: #ffffff;
            width: 100vw;
            height: 100vh;
            touch-action: none;
            position: fixed;
        }

        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
            font-weight: 300;
            z-index: 1000;
            text-align: center;
            letter-spacing: 2px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 30px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: opacity 0.5s;
        }

        .loading-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            margin: 0 4px;
            animation: loading 1.4s infinite ease-in-out;
        }

        .loading-dot:nth-child(2) { animation-delay: -0.32s; }
        .loading-dot:nth-child(3) { animation-delay: -0.16s; }

        @keyframes loading {
            0%, 80%, 100% { transform: scale(0); opacity: 0.3; }
            40% { transform: scale(1.0); opacity: 1; }
        }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    <div id="loading">
        ZAI OS<span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span>
    </div>

    <script>
// ============================================================================
// ZAI OS - FIXED WINDOW MANAGEMENT ENGINE WITH IMPROVED FOCUS MANAGEMENT
// ============================================================================
class ZAIFixedEngine {
    constructor() {
        console.log("ðŸš€ Initializing ZAI Fixed Engine with Improved Focus Management...");
        
        // Core canvas setup
        this.canvas = document.getElementById('mainCanvas');
        this.ctx = this.canvas.getContext('2d', {
            alpha: false,
            desynchronized: true,
            powerPreference: 'high-performance'
        });
        
        if (!this.ctx) {
            alert("âŒ Canvas 2D not supported. Please use a modern browser.");
            return;
        }
        
        // Reference dimensions (16:9 ratio)
        this.refWidth = 1920;
        this.refHeight = 1080;
        
        // Current scaling factors
        this.scaleX = 1;
        this.scaleY = 1;
        this.scaleMin = 1;
        this.pixelRatio = Math.min(2, window.devicePixelRatio || 1);
        
        // Engine state
        this.running = true;
        this.lastFrameTime = 0;
        this.frameCount = 0;
        this.fps = 60;
        
        // UI Components
        this.dock = new FixedDock(this);
        this.windows = [];
        this.activeWindow = null;
        this.windowCounter = { maspot: 0, fund: 0, settings: 0 };
        
        // Input state
        this.mouse = {
            x: 0, y: 0,
            down: false,
            drag: null
        };
        
        // Snap zones
        this.snapThreshold = 0.02;
        
        // Performance tracking
        this.perfStats = {
            fps: 0,
            frameTime: 0,
            windows: 0,
            lastUpdate: 0
        };
        
        // Initialize
        this.initialize();
    }
    
    initialize() {
        // Set initial canvas size
        this.resize();
        
        // Setup event listeners
        this.setupEventListeners();
        
        // Hide loading screen
        setTimeout(() => {
            document.getElementById('loading').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 500);
        }, 1000);
        
        // Start animation loop
        this.animate();
        
        console.log("âœ… ZAI Fixed Engine ready");
    }
    
    setupEventListeners() {
        // Window resize
        window.addEventListener('resize', () => this.resize());
        
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        document.addEventListener('mouseup', () => this.onMouseUp());
        document.addEventListener('mouseleave', () => this.onMouseUp());
        
        // Touch events
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (e.touches[0]) {
                const touch = e.touches[0];
                this.onMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
            }
        });
        
        this.canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches[0]) {
                const touch = e.touches[0];
                this.onMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
            }
        });
        
        this.canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.onMouseUp();
        });
    }
    
    resize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Set canvas size
        this.canvas.width = width * this.pixelRatio;
        this.canvas.height = height * this.pixelRatio;
        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
        
        // Update scaling factors
        this.scaleX = width / this.refWidth;
        this.scaleY = height / this.refHeight;
        this.scaleMin = Math.min(this.scaleX, this.scaleY);
        
        // Scale context
        if (this.pixelRatio !== 1) {
            this.ctx.scale(this.pixelRatio, this.pixelRatio);
        }
        
        // Update dock
        this.dock.onResize();
        
        // Update windows
        this.windows.forEach(window => window.onResize());
    }
    
    getMousePos(e) {
        const rect = this.canvas.getBoundingClientRect();
        return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top
        };
    }
    
    // Get window at specific screen position using direct hit testing
    getWindowAtPos(relX, relY) {
        // Check windows from top to bottom (reverse order)
        for (let i = this.windows.length - 1; i >= 0; i--) {
            const window = this.windows[i];
            if (window.isMinimized) continue;
            
            if (window.isInBounds(relX, relY)) {
                return window;
            }
        }
        
        return null;
    }
    
    onMouseDown(e) {
        const pos = this.getMousePos(e);
        this.mouse.x = pos.x;
        this.mouse.y = pos.y;
        this.mouse.down = true;
        
        // Convert to relative coordinates
        const relX = pos.x / window.innerWidth;
        const relY = pos.y / window.innerHeight;
        
        // First, check if mouse is over a window using direct hit testing
        const windowAtPos = this.getWindowAtPos(relX, relY);
        
        if (windowAtPos) {
            // Found a window at this position
            this.bringToFront(windowAtPos);
            this.activeWindow = windowAtPos;
            
            // Check close button
            if (windowAtPos.isInCloseButton(relX, relY)) {
                windowAtPos.close();
                const index = this.windows.indexOf(windowAtPos);
                if (index > -1) {
                    this.windows.splice(index, 1);
                }
                if (this.activeWindow === windowAtPos) {
                    this.activeWindow = null;
                }
                return;
            }
            
            // Check resize handles
            const resizeEdge = windowAtPos.getResizeEdge(relX, relY);
            if (resizeEdge) {
                this.mouse.drag = {
                    window: windowAtPos,
                    type: 'resize',
                    edge: resizeEdge,
                    startX: relX,
                    startY: relY,
                    startWidth: windowAtPos.width,
                    startHeight: windowAtPos.height,
                    startPosX: windowAtPos.x,
                    startPosY: windowAtPos.y
                };
                return;
            }
            
            // Check title bar
            if (windowAtPos.isInTitleBar(relX, relY)) {
                this.mouse.drag = {
                    window: windowAtPos,
                    type: 'move',
                    startX: relX,
                    startY: relY,
                    startPosX: windowAtPos.x,
                    startPosY: windowAtPos.y
                };
                return;
            }
            
            // Clicked in window content area
            return;
        }
        
        // No window at position, check dock
        if (this.dock.isInBounds(relX, relY)) {
            const clickedApp = this.dock.getClickedApp(relX, relY);
            if (clickedApp) {
                this.openApp(clickedApp);
                return;
            }
        }
        
        // Clicked empty space
        this.activeWindow = null;
    }
    
    onMouseMove(e) {
        const pos = this.getMousePos(e);
        this.mouse.x = pos.x;
        this.mouse.y = pos.y;
        
        // Convert to relative coordinates
        const relX = pos.x / window.innerWidth;
        const relY = pos.y / window.innerHeight;
        
        // Update hover states for all windows
        this.windows.forEach(window => {
            if (!window.isMinimized) {
                window.updateHover(relX, relY);
            }
        });
        
        // Update dock hover state
        this.dock.updateHover(relX, relY);
        
        // Handle dragging
        if (this.mouse.down && this.mouse.drag) {
            const dx = relX - this.mouse.drag.startX;
            const dy = relY - this.mouse.drag.startY;
            
            if (this.mouse.drag.type === 'move') {
                // Move window
                let newX = this.mouse.drag.startPosX + dx;
                let newY = this.mouse.drag.startPosY + dy;
                
                // Apply snapping
                newX = this.checkSnapX(newX, this.mouse.drag.window.width);
                newY = this.checkSnapY(newY, this.mouse.drag.window.height);
                
                this.mouse.drag.window.x = newX;
                this.mouse.drag.window.y = newY;
                
            } else if (this.mouse.drag.type === 'resize') {
                // Resize window
                this.mouse.drag.window.resize(
                    this.mouse.drag.edge,
                    dx, dy,
                    this.mouse.drag.startWidth,
                    this.mouse.drag.startHeight,
                    this.mouse.drag.startPosX,
                    this.mouse.drag.startPosY
                );
                
                // Apply snapping after resize
                this.mouse.drag.window.x = this.checkSnapX(
                    this.mouse.drag.window.x,
                    this.mouse.drag.window.width
                );
                this.mouse.drag.window.y = this.checkSnapY(
                    this.mouse.drag.window.y,
                    this.mouse.drag.window.height
                );
            }
        }
        
        // Update cursor based on current position
        this.updateCursor(relX, relY);
    }
    
    onMouseUp() {
        this.mouse.down = false;
        this.mouse.drag = null;
    }
    
    updateCursor(relX, relY) {
        let cursor = 'default';
        
        // First check if we're dragging
        if (this.mouse.drag) {
            cursor = this.mouse.drag.type === 'move' ? 'grabbing' : cursor;
            return;
        }
        
        // Check windows for resize cursors
        const windowAtPos = this.getWindowAtPos(relX, relY);
        if (windowAtPos && !windowAtPos.isMinimized) {
            // Check resize edge
            const edge = windowAtPos.getResizeEdge(relX, relY);
            if (edge) {
                switch(edge) {
                    case 'n': case 's': cursor = 'ns-resize'; break;
                    case 'e': case 'w': cursor = 'ew-resize'; break;
                    case 'nw': case 'se': cursor = 'nwse-resize'; break;
                    case 'ne': case 'sw': cursor = 'nesw-resize'; break;
                }
            } else if (windowAtPos.isInTitleBar(relX, relY)) {
                cursor = 'move';
            } else if (windowAtPos.isInCloseButton(relX, relY)) {
                cursor = 'pointer';
            }
        }
        
        this.canvas.style.cursor = cursor;
    }
    
    checkSnapX(x, width) {
        const screenWidth = 1;
        const threshold = this.snapThreshold;
        
        // Snap to left edge
        if (Math.abs(x) < threshold) return 0;
        
        // Snap to right edge
        if (Math.abs(screenWidth - (x + width)) < threshold) {
            return screenWidth - width;
        }
        
        // Snap to center horizontally
        if (Math.abs(screenWidth/2 - (x + width/2)) < threshold) {
            return screenWidth/2 - width/2;
        }
        
        return x;
    }
    
    checkSnapY(y, height) {
        const screenHeight = 1;
        const threshold = this.snapThreshold;
        
        // Snap to top edge
        if (Math.abs(y) < threshold) return 0;
        
        // Snap to bottom edge (leave space for dock)
        if (Math.abs(screenHeight - (y + height + 0.1)) < threshold) {
            return screenHeight - height - 0.1;
        }
        
        // Snap to center vertically
        if (Math.abs(screenHeight/2 - (y + height/2)) < threshold) {
            return screenHeight/2 - height/2;
        }
        
        return y;
    }
    
    bringToFront(window) {
        const index = this.windows.indexOf(window);
        if (index > -1 && index < this.windows.length - 1) {
            // Only move if not already at front
            this.windows.splice(index, 1);
            this.windows.push(window);
        }
    }
    
    openApp(appType) {
        console.log(`Opening ${appType} app...`);
        
        // Increment window counter for this app type
        this.windowCounter[appType]++;
        
        // Create unique window ID
        const windowId = `${appType}-${this.windowCounter[appType]}`;
        
        // Calculate position for new window
        let x, y;
        const existingSameType = this.windows.filter(w => w.appType === appType).length;
        
        if (appType === 'settings') {
            // Settings window in center
            x = 0.3;
            y = 0.2;
        } else if (existingSameType === 0) {
            // First window of this type
            x = appType === 'maspot' ? 0.1 : 0.55;
            y = 0.1;
        } else {
            // Subsequent window - offset slightly
            x = 0.15 + (existingSameType * 0.05);
            y = 0.15 + (existingSameType * 0.05);
        }
        
        const config = {
            id: windowId,
            title: appType === 'maspot' ? 'MA/SPOT ANALYSIS' : 
                  appType === 'fund' ? 'FUND DASHBOARD' : 'WINDOW MANAGER',
            subtitle: appType === 'maspot' ? 'Market Analytics Dashboard' : 
                     appType === 'fund' ? 'ZSD Performance Metrics' : 'System Resources',
            x: x,
            y: y,
            width: appType === 'settings' ? 0.4 : 0.35,
            height: appType === 'settings' ? 0.6 : 0.5,
            appType: appType,
            accentColor: appType === 'maspot' ? '#FFFFFF' : 
                         appType === 'fund' ? '#888888' : '#4A90E2',
            windowNumber: this.windowCounter[appType]
        };
        
        const newWindow = new FixedWindow(this, config);
        this.windows.push(newWindow);
        this.bringToFront(newWindow);
        this.activeWindow = newWindow;
        
        console.log(`âœ… ${appType} window ${this.windowCounter[appType]} opened`);
        console.log(`Total windows: ${this.windows.length}`);
    }
    
    animate(timestamp = 0) {
        if (!this.running) return;
        
        // Calculate delta time
        const deltaTime = timestamp - this.lastFrameTime || 16.67;
        this.lastFrameTime = timestamp;
        
        // Update FPS
        this.frameCount++;
        if (timestamp - this.perfStats.lastUpdate >= 1000) {
            this.perfStats.fps = this.frameCount;
            this.frameCount = 0;
            this.perfStats.lastUpdate = timestamp;
            this.perfStats.windows = this.windows.length;
        }
        
        // Clear canvas
        this.clearCanvas();
        
        // Draw background
        this.drawBackground();
        
        // Update and draw windows
        this.windows.forEach(window => {
            window.update(deltaTime);
            window.draw(this.ctx);
        });
        
        // Draw dock
        this.dock.draw(this.ctx);
        
        // Draw status bar
        this.drawStatusBar();
        
        // Continue animation
        requestAnimationFrame((t) => this.animate(t));
    }
    
    clearCanvas() {
        const width = this.canvas.width / this.pixelRatio;
        const height = this.canvas.height / this.pixelRatio;
        
        // Gradient background
        const gradient = this.ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, '#000000');
        gradient.addColorStop(0.5, '#0a0a0a');
        gradient.addColorStop(1, '#000000');
        
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, width, height);
    }
    
    drawBackground() {
        const width = this.canvas.width / this.pixelRatio;
        const height = this.canvas.height / this.pixelRatio;
        const ctx = this.ctx;
        
        // Draw subtle grid
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
        ctx.lineWidth = 1;
        
        const gridSize = 50 * this.scaleMin;
        
        for (let x = 0; x < width; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
        }
        
        for (let y = 0; y < height; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }
        
        // Grey radiant effect
        ctx.save();
        ctx.globalAlpha = 0.1;
        
        const centers = [
            { x: width * 0.3, y: height * 0.3, size: width * 0.5 },
            { x: width * 0.7, y: height * 0.7, size: width * 0.4 },
            { x: width * 0.2, y: height * 0.8, size: width * 0.3 }
        ];
        
        centers.forEach(center => {
            const gradient = ctx.createRadialGradient(
                center.x, center.y, 0,
                center.x, center.y, center.size
            );
            gradient.addColorStop(0, 'rgba(200, 200, 200, 0.3)');
            gradient.addColorStop(0.5, 'rgba(150, 150, 150, 0.1)');
            gradient.addColorStop(1, 'rgba(100, 100, 100, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
        });
        
        ctx.restore();
    }
    
    drawStatusBar() {
        const width = this.canvas.width / this.pixelRatio;
        const height = this.canvas.height / this.pixelRatio;
        const ctx = this.ctx;
        
        // Status bar
        const gradient = ctx.createLinearGradient(0, 0, 0, 40);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0.02)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, 40);
        
        // Border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, 40);
        ctx.lineTo(width, 40);
        ctx.stroke();
        
        // Current time
        const now = new Date();
        const timeStr = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        const dateStr = now.toLocaleDateString([], { weekday: 'short', month: 'short', day: 'numeric' });
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = `400 ${12 * this.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.textAlign = 'left';
        ctx.fillText(timeStr, 20, 25);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.font = `300 ${10 * this.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.fillText(dateStr, 20, 40);
        
        // System status
        ctx.textAlign = 'right';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = `400 ${11 * this.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.fillText('ZAI OS', width - 20, 25);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.font = `300 ${10 * this.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.fillText(`${this.perfStats.fps} FPS â€¢ ${this.windows.length} WINDOWS`, width - 20, 40);
    }
}

// ============================================================================
// FIXED DOCK
// ============================================================================
class FixedDock {
    constructor(engine) {
        this.engine = engine;
        this.apps = [
            { id: 'maspot', label: 'MA/SPOT', icon: 'ðŸ“ˆ', hover: false },
            { id: 'fund', label: 'FUND', icon: 'ðŸ’°', hover: false },
            { id: 'settings', label: 'SETTINGS', icon: 'âš™ï¸', hover: false }
        ];
        this.height = 0.08;
        this.padding = 0.02;
        this.onResize();
    }
    
    onResize() {
        this.y = 1 - this.height + this.padding;
        this.appWidth = 0.08;
        this.appSpacing = 0.01;
    }
    
    isInBounds(relX, relY) {
        return relY >= this.y && relY <= this.y + this.height;
    }
    
    getClickedApp(relX, relY) {
        if (!this.isInBounds(relX, relY)) return null;
        
        const totalWidth = this.apps.length * this.appWidth + (this.apps.length - 1) * this.appSpacing;
        const startX = (1 - totalWidth) / 2;
        
        for (let i = 0; i < this.apps.length; i++) {
            const appX = startX + i * (this.appWidth + this.appSpacing);
            if (relX >= appX && relX <= appX + this.appWidth) {
                return this.apps[i].id;
            }
        }
        return null;
    }
    
    updateHover(relX, relY) {
        if (!this.isInBounds(relX, relY)) {
            this.apps.forEach(app => app.hover = false);
            return;
        }
        
        const totalWidth = this.apps.length * this.appWidth + (this.apps.length - 1) * this.appSpacing;
        const startX = (1 - totalWidth) / 2;
        
        this.apps.forEach((app, i) => {
            const appX = startX + i * (this.appWidth + this.appSpacing);
            app.hover = relX >= appX && relX <= appX + this.appWidth;
        });
    }
    
    draw(ctx) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const absY = this.y * height;
        const absHeight = this.height * height;
        
        // Dock background
        ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        ctx.beginPath();
        ctx.roundRect(0, absY, width, absHeight, 20 * this.engine.scaleMin);
        ctx.fill();
        
        // Dock border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Draw apps
        const totalWidth = this.apps.length * this.appWidth + (this.apps.length - 1) * this.appSpacing;
        const startX = ((1 - totalWidth) / 2) * width;
        const appAbsWidth = this.appWidth * width;
        
        this.apps.forEach((app, i) => {
            const appX = startX + i * (appAbsWidth + this.appSpacing * width);
            const appCenterX = appX + appAbsWidth / 2;
            const appCenterY = absY + absHeight / 2;
            const iconSize = Math.min(appAbsWidth, absHeight) * 0.7;
            
            // App icon background
            if (app.hover) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
                ctx.shadowBlur = 20 * this.engine.scaleMin;
            } else {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.shadowColor = 'transparent';
            }
            
            ctx.beginPath();
            ctx.roundRect(
                appCenterX - iconSize/2,
                appCenterY - iconSize/2,
                iconSize,
                iconSize,
                12 * this.engine.scaleMin
            );
            ctx.fill();
            ctx.shadowColor = 'transparent';
            
            // App icon
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = `300 ${iconSize * 0.5}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(app.icon, appCenterX, appCenterY);
            
            // App label
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = `300 ${10 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
            ctx.fillText(app.label, appCenterX, appCenterY + iconSize/2 + 15 * this.engine.scaleMin);
        });
    }
}

// ============================================================================
// FIXED WINDOW
// ============================================================================
class FixedWindow {
    constructor(engine, config) {
        this.engine = engine;
        this.id = config.id;
        this.title = config.title;
        this.subtitle = config.subtitle;
        this.x = config.x;
        this.y = config.y;
        this.width = config.width;
        this.height = config.height;
        this.appType = config.appType;
        this.accentColor = config.accentColor;
        this.windowNumber = config.windowNumber;
        
        // Window state
        this.isMinimized = false;
        this.isMaximized = false;
        this.closeHovered = false;
        this.hoverEdge = null;
        
        // Memory usage simulation
        this.memoryUsage = Math.floor(Math.random() * 50) + 10; // MB
        
        // Resize handle size
        this.resizeHandleSize = 0.01;
        
        // Create app content
        this.app = this.appType === 'maspot' ? 
            new FixedMASpotGraph(this) : 
            this.appType === 'fund' ? 
            new FixedFundGraph(this) : 
            new FixedSettingsWindow(this);
        
        // Window constraints
        this.minWidth = 0.2;
        this.minHeight = 0.15;
        this.maxWidth = 0.9;
        this.maxHeight = 0.8;
        
        // Calculate title bar height
        this.titleBarHeight = Math.max(40, 40 * this.engine.scaleMin) / window.innerHeight;
    }
    
    onResize() {
        // Update title bar height
        this.titleBarHeight = Math.max(40, 40 * this.engine.scaleMin) / window.innerHeight;
        
        // Keep window on screen
        this.x = Math.max(0, Math.min(1 - this.width, this.x));
        this.y = Math.max(0, Math.min(1 - this.height, this.y));
        this.width = Math.max(this.minWidth, Math.min(this.maxWidth, this.width));
        this.height = Math.max(this.minHeight, Math.min(this.maxHeight, this.height));
    }
    
    isInBounds(relX, relY) {
        if (this.isMinimized) return false;
        return relX >= this.x && relX <= this.x + this.width &&
               relY >= this.y && relY <= this.y + this.height;
    }
    
    isInTitleBar(relX, relY) {
        if (this.isMinimized) return false;
        return relX >= this.x && relX <= this.x + this.width &&
               relY >= this.y && relY <= this.y + this.titleBarHeight;
    }
    
    isInCloseButton(relX, relY) {
        if (this.isMinimized) return false;
        const absX = relX * window.innerWidth;
        const absY = relY * window.innerHeight;
        const closeX = (this.x + this.width) * window.innerWidth - 40 * this.engine.scaleMin;
        const closeY = this.y * window.innerHeight + 15 * this.engine.scaleMin;
        const closeSize = 20 * this.engine.scaleMin;
        
        return absX >= closeX && absX <= closeX + closeSize &&
               absY >= closeY && absY <= closeY + closeSize;
    }
    
    getResizeEdge(relX, relY) {
        if (this.isMinimized || this.isMaximized) return null;
        
        const edgeThreshold = this.resizeHandleSize;
        
        // Check corners
        if (relX <= this.x + edgeThreshold && relY <= this.y + edgeThreshold) return 'nw';
        if (relX >= this.x + this.width - edgeThreshold && relY <= this.y + edgeThreshold) return 'ne';
        if (relX <= this.x + edgeThreshold && relY >= this.y + this.height - edgeThreshold) return 'sw';
        if (relX >= this.x + this.width - edgeThreshold && relY >= this.y + this.height - edgeThreshold) return 'se';
        
        // Check edges
        if (relX <= this.x + edgeThreshold) return 'w';
        if (relX >= this.x + this.width - edgeThreshold) return 'e';
        if (relY <= this.y + edgeThreshold) return 'n';
        if (relY >= this.y + this.height - edgeThreshold) return 's';
        
        return null;
    }
    
    updateHover(relX, relY) {
        this.closeHovered = this.isInCloseButton(relX, relY);
        this.hoverEdge = this.getResizeEdge(relX, relY);
    }
    
    resize(edge, dx, dy, startWidth, startHeight, startX, startY) {
        const minSize = 0.05;
        
        switch(edge) {
            case 'n':
                this.height = Math.max(minSize, Math.min(this.maxHeight, startHeight - dy));
                this.y = startY + dy;
                break;
            case 's':
                this.height = Math.max(minSize, Math.min(this.maxHeight, startHeight + dy));
                break;
            case 'w':
                this.width = Math.max(minSize, Math.min(this.maxWidth, startWidth - dx));
                this.x = startX + dx;
                break;
            case 'e':
                this.width = Math.max(minSize, Math.min(this.maxWidth, startWidth + dx));
                break;
            case 'nw':
                this.width = Math.max(minSize, Math.min(this.maxWidth, startWidth - dx));
                this.height = Math.max(minSize, Math.min(this.maxHeight, startHeight - dy));
                this.x = startX + dx;
                this.y = startY + dy;
                break;
            case 'ne':
                this.width = Math.max(minSize, Math.min(this.maxWidth, startWidth + dx));
                this.height = Math.max(minSize, Math.min(this.maxHeight, startHeight - dy));
                this.y = startY + dy;
                break;
            case 'sw':
                this.width = Math.max(minSize, Math.min(this.maxWidth, startWidth - dx));
                this.height = Math.max(minSize, Math.min(this.maxHeight, startHeight + dy));
                this.x = startX + dx;
                break;
            case 'se':
                this.width = Math.max(minSize, Math.min(this.maxWidth, startWidth + dx));
                this.height = Math.max(minSize, Math.min(this.maxHeight, startHeight + dy));
                break;
        }
        
        // Keep window on screen
        this.x = Math.max(0, Math.min(1 - this.width, this.x));
        this.y = Math.max(0, Math.min(1 - this.height, this.y));
    }
    
    close() {
        this.app.cleanup();
        console.log(`Closed window: ${this.id}`);
    }
    
    update(deltaTime) {
        if (!this.isMinimized) {
            this.app.update(deltaTime);
            
            // Simulate memory usage fluctuation
            if (Math.random() < 0.01) {
                this.memoryUsage = Math.floor(Math.random() * 50) + 10;
            }
        }
    }
    
    draw(ctx) {
        if (this.isMinimized) return;
        
        const width = window.innerWidth;
        const height = window.innerHeight;
        const absX = this.x * width;
        const absY = this.y * height;
        const absWidth = this.width * width;
        const absHeight = this.height * height;
        
        // Calculate absolute title bar height
        const titleBarHeight = Math.max(40, 40 * this.engine.scaleMin);
        
        // Window shadow
        ctx.save();
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
        ctx.shadowBlur = 30 * this.engine.scaleMin;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 10 * this.engine.scaleMin;
        
        // Window background
        ctx.fillStyle = 'rgba(25, 25, 25, 0.98)';
        ctx.beginPath();
        ctx.roundRect(absX, absY, absWidth, absHeight, 12 * this.engine.scaleMin);
        ctx.fill();
        
        ctx.restore();
        
        // Title bar gradient
        const titleGradient = ctx.createLinearGradient(absX, absY, absX, absY + titleBarHeight);
        titleGradient.addColorStop(0, 'rgba(200, 200, 200, 0.1)');
        titleGradient.addColorStop(0.5, 'rgba(150, 150, 150, 0.05)');
        titleGradient.addColorStop(1, 'rgba(100, 100, 100, 0.02)');
        
        ctx.fillStyle = titleGradient;
        ctx.beginPath();
        ctx.roundRect(absX, absY, absWidth, titleBarHeight, 
                      12 * this.engine.scaleMin, 12 * this.engine.scaleMin, 0, 0);
        ctx.fill();
        
        // Active window indicator (blue line)
        if (this.engine.activeWindow === this) {
            ctx.fillStyle = '#4A90E2';
            ctx.fillRect(absX, absY, absWidth, 3 * this.engine.scaleMin);
        }
        
        // Title bar border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(absX, absY + titleBarHeight);
        ctx.lineTo(absX + absWidth, absY + titleBarHeight);
        ctx.stroke();
        
        // Window title with number if multiple windows
        const title = this.windowNumber > 1 ? 
            `${this.title} (${this.windowNumber})` : this.title;
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = `500 ${14 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        ctx.fillText(title, absX + 20, absY + titleBarHeight/2);
        
        // Window subtitle
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.font = `300 ${11 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.fillText(this.subtitle, absX + 20, absY + titleBarHeight/2 + 20);
        
        // Memory usage indicator
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.font = `300 ${10 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.textAlign = 'right';
        ctx.fillText(`${this.memoryUsage} MB`, absX + absWidth - 60, absY + titleBarHeight/2);
        
        // Close button
        const closeX = absX + absWidth - 40 * this.engine.scaleMin;
        const closeY = absY + 15 * this.engine.scaleMin;
        const closeSize = 20 * this.engine.scaleMin;
        
        ctx.fillStyle = this.closeHovered ? 'rgba(255, 59, 48, 0.8)' : 'rgba(255, 59, 48, 0.4)';
        ctx.beginPath();
        ctx.roundRect(closeX, closeY, closeSize, closeSize, 4 * this.engine.scaleMin);
        ctx.fill();
        
        ctx.fillStyle = '#ffffff';
        ctx.font = `bold ${12 * this.engine.scaleMin}px Arial`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('Ã—', closeX + closeSize/2, closeY + closeSize/2);
        
        // Content area
        const contentX = absX;
        const contentY = absY + titleBarHeight;
        const contentWidth = absWidth;
        const contentHeight = absHeight - titleBarHeight;
        
        // Draw app content
        ctx.save();
        ctx.beginPath();
        ctx.rect(contentX, contentY, contentWidth, contentHeight);
        ctx.clip();
        
        this.app.draw(ctx, contentX, contentY, contentWidth, contentHeight);
        ctx.restore();
        
        // Draw resize handles only when mouse is over THIS window
        if (this.hoverEdge && !this.isMaximized && this.engine.activeWindow === this) {
            const handleSize = 8 * this.engine.scaleMin;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            
            // Draw corner handles
            ctx.fillRect(absX, absY, handleSize, handleSize);
            ctx.fillRect(absX + absWidth - handleSize, absY, handleSize, handleSize);
            ctx.fillRect(absX, absY + absHeight - handleSize, handleSize, handleSize);
            ctx.fillRect(absX + absWidth - handleSize, absY + absHeight - handleSize, handleSize, handleSize);
        }
    }
}

// ============================================================================
// SIMPLE GRAPH CLASSES
// ============================================================================
class BaseFixedGraph {
    constructor(window) {
        this.window = window;
        this.engine = window.engine;
        this.data = [];
        this.lastUpdate = 0;
        this.generateInitialData();
    }
    
    generateInitialData() {
        const baseValue = this.window.appType === 'maspot' ? 25000 : 1000;
        for (let i = 0; i < 100; i++) {
            this.data.push({
                block: 1000000 + i * 100,
                value: baseValue + (Math.random() - 0.5) * baseValue * 0.2,
                timestamp: Date.now() - (100 - i) * 60000
            });
        }
    }
    
    update(deltaTime) {
        const now = Date.now();
        if (now - this.lastUpdate > 1000) {
            this.updateData();
            this.lastUpdate = now;
        }
    }
    
    updateData() {
        if (this.data.length === 0) return;
        
        const baseValue = this.window.appType === 'maspot' ? 25000 : 1000;
        const lastValue = this.data[this.data.length - 1].value;
        const change = (Math.random() - 0.5) * 0.02;
        const newValue = Math.max(baseValue * 0.5, Math.min(baseValue * 1.5, lastValue * (1 + change)));
        
        this.data.push({
            block: this.data[this.data.length - 1].block + 100,
            value: newValue,
            timestamp: Date.now()
        });
        
        if (this.data.length > 200) {
            this.data.shift();
        }
    }
    
    formatValue(value) {
        const isMASpot = this.window.appType === 'maspot';
        const prefix = isMASpot ? '$' : '$';
        const suffix = isMASpot ? '' : ' ZSD';
        return `${prefix}${value.toLocaleString('en-US', {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        })}${suffix}`;
    }
    
    draw(ctx, x, y, width, height) {
        // Background
        ctx.fillStyle = 'rgba(30, 30, 35, 0.9)';
        ctx.fillRect(x, y, width, height);
        
        if (this.data.length < 2) return;
        
        // Calculate bounds
        const values = this.data.map(d => d.value);
        const minValue = Math.min(...values) * 0.99;
        const maxValue = Math.max(...values) * 1.01;
        const valueRange = Math.max(0.0001, maxValue - minValue);
        
        // Draw grid
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        
        // Horizontal grid
        for (let i = 0; i <= 5; i++) {
            const lineY = y + (i * height / 5);
            ctx.beginPath();
            ctx.moveTo(x, lineY);
            ctx.lineTo(x + width, lineY);
            ctx.stroke();
            
            // Grid labels
            const value = maxValue - (i * valueRange / 5);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = `300 ${10 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
            ctx.textAlign = 'right';
            ctx.fillText(this.formatValue(value), x - 8, lineY + 3);
        }
        
        // Vertical grid
        for (let i = 0; i <= 5; i++) {
            const lineX = x + (i * width / 5);
            ctx.beginPath();
            ctx.moveTo(lineX, y);
            ctx.lineTo(lineX, y + height);
            ctx.stroke();
        }
        
        // Draw graph line
        ctx.beginPath();
        for (let i = 0; i < this.data.length; i++) {
            const point = this.data[i];
            const pointX = x + (i / (this.data.length - 1)) * width;
            const pointY = y + ((maxValue - point.value) / valueRange) * height;
            
            if (i === 0) {
                ctx.moveTo(pointX, pointY);
            } else {
                ctx.lineTo(pointX, pointY);
            }
        }
        
        // Line gradient
        const gradient = ctx.createLinearGradient(x, y, x, y + height);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
        gradient.addColorStop(0.5, 'rgba(200, 200, 200, 0.6)');
        gradient.addColorStop(1, 'rgba(150, 150, 150, 0.3)');
        
        ctx.strokeStyle = gradient;
        ctx.lineWidth = 2 * this.engine.scaleMin;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        ctx.stroke();
        
        // Draw current value
        const lastPoint = this.data[this.data.length - 1];
        const lastX = x + width;
        const lastY = y + ((maxValue - lastPoint.value) / valueRange) * height;
        
        // Value indicator
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        ctx.arc(lastX, lastY, 15 * this.engine.scaleMin, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(lastX, lastY, 6 * this.engine.scaleMin, 0, Math.PI * 2);
        ctx.fill();
        
        // Value label
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.font = `600 ${18 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.formatValue(lastPoint.value), lastX - 20, lastY);
        
        // Axis labels
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.font = `400 ${11 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText('BLOCK', x + width/2, y + height - 10);
        
        // Y-axis label
        ctx.save();
        ctx.translate(x + 15, y + height/2);
        ctx.rotate(-Math.PI/2);
        ctx.fillText(this.window.appType === 'maspot' ? 'PRICE (USD)' : '$ZSD', 0, 0);
        ctx.restore();
    }
    
    cleanup() {
        // Cleanup
    }
}

class FixedMASpotGraph extends BaseFixedGraph {
    // Inherits everything
}

class FixedFundGraph extends BaseFixedGraph {
    // Inherits everything
}

class FixedSettingsWindow {
    constructor(window) {
        this.window = window;
        this.engine = window.engine;
        this.lastUpdate = 0;
    }
    
    update(deltaTime) {
        // Update settings window data
    }
    
    draw(ctx, x, y, width, height) {
        // Background
        ctx.fillStyle = 'rgba(30, 30, 35, 0.9)';
        ctx.fillRect(x, y, width, height);
        
        // Title
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = `600 ${18 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText('WINDOW MANAGER', x + width/2, y + 40);
        
        // Window list
        ctx.font = `400 ${14 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.textAlign = 'left';
        
        const startY = y + 80;
        const lineHeight = 30;
        
        // Draw header
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.fillText('Active Windows:', x + 20, startY);
        
        // Draw window list
        this.engine.windows.forEach((window, index) => {
            const isActive = this.engine.activeWindow === window;
            const yPos = startY + (index + 1) * lineHeight;
            
            // Highlight active window
            if (isActive) {
                ctx.fillStyle = 'rgba(74, 144, 226, 0.2)';
                ctx.fillRect(x + 10, yPos - 15, width - 20, 25);
            }
            
            // Window info
            ctx.fillStyle = isActive ? 'rgba(255, 255, 255, 0.9)' : 'rgba(255, 255, 255, 0.6)';
            ctx.fillText(`${window.title} (${window.memoryUsage} MB)`, x + 30, yPos);
            
            // Active indicator
            if (isActive) {
                ctx.fillStyle = '#4A90E2';
                ctx.beginPath();
                ctx.arc(x + 20, yPos - 5, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        });
        
        // System resources
        const resourcesY = startY + (this.engine.windows.length + 2) * lineHeight;
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.fillText('System Resources:', x + 20, resourcesY);
        
        // Memory usage bar
        const totalMemory = 512; // MB
        const usedMemory = this.engine.windows.reduce((sum, window) => sum + window.memoryUsage, 0);
        const memoryPercent = usedMemory / totalMemory;
        
        // Memory bar background
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(x + 20, resourcesY + 20, width - 40, 20);
        
        // Memory bar fill
        const gradient = ctx.createLinearGradient(x + 20, 0, x + 20 + (width - 40) * memoryPercent, 0);
        gradient.addColorStop(0, '#4A90E2');
        gradient.addColorStop(1, '#5DADE2');
        ctx.fillStyle = gradient;
        ctx.fillRect(x + 20, resourcesY + 20, (width - 40) * memoryPercent, 20);
        
        // Memory text
        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.font = `300 ${12 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(`${usedMemory} MB / ${totalMemory} MB (${Math.round(memoryPercent * 100)}%)`, x + width/2, resourcesY + 35);
        
        // Performance metrics
        const metricsY = resourcesY + 70;
        ctx.textAlign = 'left';
        ctx.font = `400 ${14 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.fillText('Performance:', x + 20, metricsY);
        
        ctx.font = `300 ${12 * this.engine.scaleMin}px -apple-system, BlinkMacSystemFont, sans-serif`;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.fillText(`FPS: ${this.engine.perfStats.fps}`, x + 30, metricsY + 25);
        ctx.fillText(`Windows: ${this.engine.windows.length}`, x + 30, metricsY + 45);
        
        // Z logo
        const logoSize = 80 * this.engine.scaleMin;
        const logoX = x + width/2 - logoSize/2;
        const logoY = y + height - logoSize - 30;
        
        // Draw Z logo
        ctx.save();
        ctx.strokeStyle = '#4A90E2';
        ctx.lineWidth = 8 * this.engine.scaleMin;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // Draw Z shape
        ctx.beginPath();
        ctx.moveTo(logoX, logoY);
        ctx.lineTo(logoX + logoSize, logoY);
        ctx.lineTo(logoX, logoY + logoSize);
        ctx.lineTo(logoX + logoSize, logoY + logoSize);
        ctx.stroke();
        
        ctx.restore();
    }
    
    cleanup() {
        // Cleanup
    }
}

// ============================================================================
// INITIALIZE ENGINE
// ============================================================================
window.addEventListener('load', () => {
    console.log("ðŸš€ Launching ZAI OS with Improved Focus Management...");
    
    try {
        // Initialize the fixed engine
        const zaiEngine = new ZAIFixedEngine();
        window.zaiEngine = zaiEngine;
        
        // REMOVED auto-opening of windows
        // Now you can open windows by clicking the dock icons
        
        console.log("âœ… ZAI OS successfully launched - Click dock icons to open windows");
        
    } catch (error) {
        console.error("âŒ Failed to initialize ZAI OS:", error);
        document.getElementById('loading').innerHTML = 
            `<div style="color: #ff453a;">Error: ${error.message}</div>`;
    }
});
    </script>
</body>
</html>
