<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<head>
<style>
body{
margin:0;
padding:0;
overflow:hidden;
-webkit-tap-highlight-color: transparent;
-webkit-touch-callout: none;
-webkit-user-select: none;
user-select: none;
background:#000;
}
canvas{
position:absolute;
top:0;
left:0;
display:block;
}
#canvas3d{
z-index:1;
}
#canvasGraph{
z-index:2;
}
#canvasUI{
z-index:3;
cursor:pointer;
}
#debug{
position:fixed;
top:10px;
right:10px;
color:#0f0;
font:12px monospace;
text-shadow:1px 1px 0 #000;
z-index:4;
}
#menuBtn{
position:fixed;
top:20px;
left:20px;
width:40px;
height:40px;
background:rgba(30,30,30,0.9);
border:1px solid #444;
border-radius:8px;
color:#4af;
font:20px monospace;
z-index:4;
cursor:pointer;
display:flex;
align-items:center;
justify-content:center;
transition:all 0.2s;
}
#menuBtn:hover{
background:rgba(50,50,50,0.9);
transform:scale(1.05);
}
#controls{
position:fixed;
top:70px;
left:20px;
width:280px;
background:rgba(20,20,25,0.95);
border:1px solid #334;
border-radius:10px;
padding:20px;
z-index:4;
transform:translateX(-350px);
transition:transform 0.3s cubic-bezier(0.4,0,0.2,1);
backdrop-filter:blur(10px);
}
#controls.show{
transform:translateX(0);
}
.control-group{
margin-bottom:20px;
}
h3{
margin:0 0 15px 0;
color:#4af;
font:600 18px sans-serif;
}
label{
display:block;
margin:10px 0 5px;
color:#8af;
font:12px monospace;
}
input{
width:100%;
box-sizing:border-box;
padding:8px;
background:rgba(10,15,30,0.8);
border:1px solid #456;
border-radius:4px;
color:#eef;
font:12px monospace;
}
input:focus{
outline:none;
border-color:#4af;
}
button{
width:100%;
padding:10px;
margin:5px 0;
background:linear-gradient(135deg,#2a4a8f,#1a3a7f);
border:none;
border-radius:6px;
color:#fff;
font:12px monospace;
cursor:pointer;
transition:all 0.2s;
}
button:hover{
background:linear-gradient(135deg,#3a5a9f,#2a4a8f);
transform:translateY(-1px);
}
#dataList{
max-height:200px;
overflow-y:auto;
margin-top:15px;
padding-top:15px;
border-top:1px solid #334;
}
.data-item{
padding:6px 0;
border-bottom:1px solid #223;
font:11px monospace;
display:flex;
justify-content:space-between;
}
.data-date{
color:#8af;
}
.data-value{
color:#4fa;
}
#dataList::-webkit-scrollbar{width:6px;}
#dataList::-webkit-scrollbar-track{background:rgba(10,15,30,0.5);}
#dataList::-webkit-scrollbar-thumb{background:#456;border-radius:3px;}
#dataList::-webkit-scrollbar-thumb:hover{background:#4af;}
</style>

<script>
"use strict";

// ============================================================================
// ULTRA-OPTIMIZED 3D ENGINE WITH WEBGL
// ============================================================================
class WebGLTriangleEngine {
    constructor(canvas) {
        this.canvas = canvas;
        this.gl = canvas.getContext('webgl2', {
            alpha: false,
            desynchronized: true,
            powerPreference: 'high-performance',
            failIfMajorPerformanceCaveat: false,
            preserveDrawingBuffer: false,
            antialias: false
        });
        
        if (!this.gl) {
            // Fallback to WebGL 1.0
            this.gl = canvas.getContext('webgl', {
                alpha: false,
                desynchronized: true,
                powerPreference: 'high-performance',
                failIfMajorPerformanceCaveat: false,
                preserveDrawingBuffer: false,
                antialias: false
            }) || canvas.getContext('experimental-webgl');
        }
        
        this.width = 0;
        this.height = 0;
        this.time = 0;
        
        // Performance metrics
        this.triangleCount = 0;
        this.maxTriangles = 2000; // WebGL can handle much more
        
        // WebGL resources
        this.program = null;
        this.vertexBuffer = null;
        this.colorBuffer = null;
        this.indexBuffer = null;
        
        // Uniform locations
        this.uniforms = {
            time: null,
            resolution: null,
            camera: null
        };
        
        // Performance optimization: adaptive quality
        this.targetFPS = 60;
        this.currentFPS = 60;
        this.adaptiveQuality = 1.0;
        this.frameTimeHistory = new Float32Array(10);
        this.frameTimeIndex = 0;
        
        this.init();
        this.resize();
    }
    
    init() {
        const gl = this.gl;
        
        // Vertex shader with position and color
        const vsSource = `
            attribute vec3 aPosition;
            attribute vec4 aColor;
            
            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec3 uCamera;
            
            varying vec4 vColor;
            varying float vDepth;
            
            // Fast rotation functions without trig
            vec3 fastRotateY(vec3 p, float angle) {
                float s = sin(angle);
                float c = cos(angle);
                return vec3(p.x * c - p.z * s, p.y, p.x * s + p.z * c);
            }
            
            vec3 fastRotateX(vec3 p, float angle) {
                float s = sin(angle);
                float c = cos(angle);
                return vec3(p.x, p.y * c - p.z * s, p.y * s + p.z * c);
            }
            
            void main() {
                vec3 pos = aPosition;
                
                // Apply rotations
                pos = fastRotateY(pos, uTime * 0.0002 + aPosition.x * 0.001);
                pos = fastRotateX(pos, uTime * 0.0003 + aPosition.y * 0.001);
                
                // Move triangles
                pos.z += sin(uTime * 0.001 + aPosition.x * 0.01) * 50.0;
                
                // Perspective projection
                float fov = 800.0;
                float scale = fov / (uCamera.z - pos.z);
                vec2 projectedPos = pos.xy * scale + uResolution.xy * 0.5;
                
                gl_Position = vec4(projectedPos / uResolution.xy * 2.0 - 1.0, 0.0, 1.0);
                vColor = aColor;
                vDepth = pos.z;
            }
        `;
        
        // Fragment shader with depth-based fog
        const fsSource = `
            precision mediump float;
            
            varying vec4 vColor;
            varying float vDepth;
            
            void main() {
                // Depth-based fog effect
                float fogFactor = 1.0 - clamp((vDepth + 600.0) / 1000.0, 0.0, 1.0);
                fogFactor = max(0.3, fogFactor);
                
                gl_FragColor = vec4(vColor.rgb * fogFactor, vColor.a);
            }
        `;
        
        // Compile shaders
        const vertexShader = this.compileShader(gl.VERTEX_SHADER, vsSource);
        const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fsSource);
        
        // Create program
        this.program = gl.createProgram();
        gl.attachShader(this.program, vertexShader);
        gl.attachShader(this.program, fragmentShader);
        gl.linkProgram(this.program);
        
        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
            console.error('Unable to initialize shader program:', gl.getProgramInfoLog(this.program));
            return;
        }
        
        gl.useProgram(this.program);
        
        // Get attribute and uniform locations
        this.attributes = {
            position: gl.getAttribLocation(this.program, 'aPosition'),
            color: gl.getAttribLocation(this.program, 'aColor')
        };
        
        this.uniforms = {
            time: gl.getUniformLocation(this.program, 'uTime'),
            resolution: gl.getUniformLocation(this.program, 'uResolution'),
            camera: gl.getUniformLocation(this.program, 'uCamera')
        };
        
        // Create buffers
        this.vertexBuffer = gl.createBuffer();
        this.colorBuffer = gl.createBuffer();
        this.indexBuffer = gl.createBuffer();
        
        // Enable attributes
        gl.enableVertexAttribArray(this.attributes.position);
        gl.enableVertexAttribArray(this.attributes.color);
        
        // Set up state
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        
        // Initialize triangles
        this.generateTriangles();
    }
    
    compileShader(type, source) {
        const gl = this.gl;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        
        return shader;
    }
    
    generateTriangles() {
        const gl = this.gl;
        
        // Adaptive triangle count based on performance
        this.triangleCount = Math.floor(this.maxTriangles * this.adaptiveQuality);
        
        // Generate vertices (3 per triangle)
        const vertices = new Float32Array(this.triangleCount * 9);
        const colors = new Float32Array(this.triangleCount * 12); // RGBA per vertex
        const indices = new Uint16Array(this.triangleCount * 3);
        
        for (let i = 0; i < this.triangleCount; i++) {
            const vOffset = i * 9;
            const cOffset = i * 12;
            const iOffset = i * 3;
            
            // Random triangle in 3D space
            for (let j = 0; j < 3; j++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 50 + Math.random() * 400;
                const height = (Math.random() - 0.5) * 600;
                
                vertices[vOffset + j * 3] = Math.cos(angle) * radius;
                vertices[vOffset + j * 3 + 1] = height;
                vertices[vOffset + j * 3 + 2] = Math.sin(angle) * radius - 600;
                
                // Color with blue-ish tint
                colors[cOffset + j * 4] = 0.1 + Math.random() * 0.3; // R
                colors[cOffset + j * 4 + 1] = 0.2 + Math.random() * 0.4; // G
                colors[cOffset + j * 4 + 2] = 0.4 + Math.random() * 0.5; // B
                colors[cOffset + j * 4 + 3] = 0.15 + Math.random() * 0.2; // A
                
                // Index
                indices[iOffset + j] = i * 3 + j;
            }
        }
        
        // Upload to GPU
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
        
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    }
    
    resize() {
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        
        if (this.gl) {
            this.gl.viewport(0, 0, this.width, this.height);
        }
    }
    
    update(deltaTime) {
        this.time += deltaTime;
        
        // Adaptive quality based on performance
        this.frameTimeHistory[this.frameTimeIndex] = deltaTime;
        this.frameTimeIndex = (this.frameTimeIndex + 1) % this.frameTimeHistory.length;
        
        if (this.frameTimeIndex === 0) {
            // Calculate average frame time
            let avgFrameTime = 0;
            for (let i = 0; i < this.frameTimeHistory.length; i++) {
                avgFrameTime += this.frameTimeHistory[i];
            }
            avgFrameTime /= this.frameTimeHistory.length;
            
            this.currentFPS = 1000 / avgFrameTime;
            
            // Adjust quality based on FPS
            if (this.currentFPS < this.targetFPS * 0.9) {
                this.adaptiveQuality = Math.max(0.5, this.adaptiveQuality - 0.05);
                this.generateTriangles(); // Regenerate with new quality
            } else if (this.currentFPS > this.targetFPS * 1.1) {
                this.adaptiveQuality = Math.min(1.0, this.adaptiveQuality + 0.05);
                this.generateTriangles(); // Regenerate with new quality
            }
        }
    }
    
    render() {
        const gl = this.gl;
        if (!gl) return;
        
        // Clear with gradient effect in shader
        gl.clearColor(0.04, 0.04, 0.1, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
        // Set uniforms
        gl.uniform1f(this.uniforms.time, this.time);
        gl.uniform2f(this.uniforms.resolution, this.width, this.height);
        gl.uniform3f(this.uniforms.camera, 0, 0, 500);
        
        // Bind vertex buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(this.attributes.position, 3, gl.FLOAT, false, 0, 0);
        
        // Bind color buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.vertexAttribPointer(this.attributes.color, 4, gl.FLOAT, false, 0, 0);
        
        // Draw triangles
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.drawElements(gl.TRIANGLES, this.triangleCount * 3, gl.UNSIGNED_SHORT, 0);
    }
}

// ============================================================================
// HYPER-OPTIMIZED 2D GRAPH ENGINE
// ============================================================================
class HyperOptimizedGraphEngine {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', {
            alpha: true,
            desynchronized: true,
            willReadFrequently: false
        });
        
        this.width = 0;
        this.height = 0;
        this.margin = {top: 60, right: 60, bottom: 80, left: 80};
        this.graphArea = {x: 0, y: 0, width: 0, height: 0};
        
        // Data management
        this.data = [];
        this.minDate = 0;
        this.maxDate = 0;
        this.minValue = 0;
        this.maxValue = 0;
        
        // Offscreen canvas for static elements
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
        
        // Rendering cache
        this.vertexCache = new Float32Array(0);
        this.needsRedraw = true;
        this.needsStaticRedraw = true;
        
        // Performance optimization
        this.dirtyRegions = [];
        this.maxDirtyRegions = 5;
        
        this.resize();
    }
    
    resize() {
        this.width = this.canvas.width = window.innerWidth;
        this.height = this.canvas.height = window.innerHeight;
        
        this.graphArea = {
            x: this.margin.left,
            y: this.margin.top,
            width: this.width - this.margin.left - this.margin.right,
            height: this.height - this.margin.top - this.margin.bottom
        };
        
        // Resize offscreen canvas
        this.offscreenCanvas.width = this.width;
        this.offscreenCanvas.height = this.height;
        
        this.needsRedraw = true;
        this.needsStaticRedraw = true;
    }
    
    setData(data) {
        this.data = data;
        this.calculateRanges();
        this.updateVertexCache();
        this.needsRedraw = true;
        this.needsStaticRedraw = true;
    }
    
    calculateRanges() {
        if (this.data.length === 0) return;
        
        this.minDate = this.data[0].date;
        this.maxDate = this.data[0].date;
        this.minValue = this.data[0].value;
        this.maxValue = this.data[0].value;
        
        for (let i = 1; i < this.data.length; i++) {
            const d = this.data[i];
            if (d.date < this.minDate) this.minDate = d.date;
            if (d.date > this.maxDate) this.maxDate = d.date;
            if (d.value < this.minValue) this.minValue = d.value;
            if (d.value > this.maxValue) this.maxValue = d.value;
        }
        
        // Add padding
        const valueRange = this.maxValue - this.minValue;
        this.minValue = Math.max(0, this.minValue - valueRange * 0.1);
        this.maxValue += valueRange * 0.1;
    }
    
    updateVertexCache() {
        if (this.data.length < 2) return;
        
        // Pre-calculate all vertex positions
        this.vertexCache = new Float32Array(this.data.length * 2);
        const dateRange = this.maxDate - this.minDate;
        const valueRange = this.maxValue - this.minValue;
        
        for (let i = 0; i < this.data.length; i++) {
            const d = this.data[i];
            const t = (d.date - this.minDate) / dateRange;
            const v = (d.value - this.minValue) / valueRange;
            
            this.vertexCache[i * 2] = this.graphArea.x + t * this.graphArea.width;
            this.vertexCache[i * 2 + 1] = this.graphArea.y + (1 - v) * this.graphArea.height;
        }
    }
    
    renderStaticElements() {
        if (!this.needsStaticRedraw) return;
        
        const ctx = this.offscreenCtx;
        ctx.clearRect(0, 0, this.width, this.height);
        
        if (this.data.length === 0) {
            this.needsStaticRedraw = false;
            return;
        }
        
        // Draw grid
        ctx.strokeStyle = 'rgba(100,120,200,0.2)';
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 3]);
        
        // Vertical grid lines
        const xSteps = 6;
        for (let i = 0; i <= xSteps; i++) {
            const x = this.graphArea.x + (i / xSteps) * this.graphArea.width;
            ctx.beginPath();
            ctx.moveTo(x, this.graphArea.y);
            ctx.lineTo(x, this.graphArea.y + this.graphArea.height);
            ctx.stroke();
        }
        
        // Horizontal grid lines
        const ySteps = 5;
        for (let i = 0; i <= ySteps; i++) {
            const y = this.graphArea.y + (i / ySteps) * this.graphArea.height;
            ctx.beginPath();
            ctx.moveTo(this.graphArea.x, y);
            ctx.lineTo(this.graphArea.x + this.graphArea.width, y);
            ctx.stroke();
        }
        
        ctx.setLineDash([]);
        
        // Draw axes
        ctx.strokeStyle = 'rgba(80,150,255,0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(this.graphArea.x, this.graphArea.y);
        ctx.lineTo(this.graphArea.x, this.graphArea.y + this.graphArea.height);
        ctx.lineTo(this.graphArea.x + this.graphArea.width, this.graphArea.y + this.graphArea.height);
        ctx.stroke();
        
        // Draw labels
        ctx.fillStyle = '#8af';
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('Date', this.graphArea.x + this.graphArea.width / 2, this.height - 30);
        
        ctx.save();
        ctx.translate(30, this.graphArea.y + this.graphArea.height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText('$ZSD Value', 0, 0);
        ctx.restore();
        
        // Title
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 16px monospace';
        ctx.fillText('$ZSD VALUE CURVE', this.width / 2, 35);
        
        this.needsStaticRedraw = false;
    }
    
    render() {
        if (!this.needsRedraw && this.data.length === 0) return;
        
        // First render static elements to offscreen canvas
        this.renderStaticElements();
        
        // Clear main canvas
        this.ctx.clearRect(0, 0, this.width, this.height);
        
        // Copy static elements from offscreen canvas
        this.ctx.drawImage(this.offscreenCanvas, 0, 0);
        
        if (this.data.length === 0) {
            this.needsRedraw = false;
            return;
        }
        
        // Draw curve if we have enough points
        if (this.data.length >= 2 && this.vertexCache.length >= 4) {
            this.ctx.beginPath();
            this.ctx.moveTo(this.vertexCache[0], this.vertexCache[1]);
            
            // Optimized curve rendering with fewer control points
            const segments = Math.min(this.data.length - 1, 20); // Limit segments for performance
            const segmentStep = Math.max(1, Math.floor((this.data.length - 1) / segments));
            
            for (let i = segmentStep; i < this.data.length; i += segmentStep) {
                const px = this.vertexCache[i * 2];
                const py = this.vertexCache[i * 2 + 1];
                
                // Simple quadratic bezier for performance
                const cpx = this.vertexCache[(i - segmentStep/2) * 2];
                const cpy = this.vertexCache[(i - segmentStep/2) * 2 + 1];
                
                this.ctx.quadraticCurveTo(cpx, cpy, px, py);
            }
            
            // Ensure we end at the last point
            if ((this.data.length - 1) % segmentStep !== 0) {
                const lastIndex = (this.data.length - 1) * 2;
                this.ctx.lineTo(this.vertexCache[lastIndex], this.vertexCache[lastIndex + 1]);
            }
            
            // Gradient stroke for the curve
            const gradient = this.ctx.createLinearGradient(
                this.graphArea.x, 0,
                this.graphArea.x + this.graphArea.width, 0
            );
            gradient.addColorStop(0, 'rgba(100,200,255,0.9)');
            gradient.addColorStop(1, 'rgba(50,150,255,0.9)');
            
            this.ctx.strokeStyle = gradient;
            this.ctx.lineWidth = 3;
            this.ctx.lineJoin = 'round';
            this.ctx.lineCap = 'round';
            this.ctx.stroke();
            
            // Fill under curve
            this.ctx.lineTo(this.vertexCache[(this.data.length-1)*2], this.graphArea.y + this.graphArea.height);
            this.ctx.lineTo(this.vertexCache[0], this.graphArea.y + this.graphArea.height);
            this.ctx.closePath();
            
            const fillGradient = this.ctx.createLinearGradient(0, this.graphArea.y, 0, this.graphArea.y + this.graphArea.height);
            fillGradient.addColorStop(0, 'rgba(50,100,200,0.3)');
            fillGradient.addColorStop(1, 'rgba(20,50,100,0.1)');
            this.ctx.fillStyle = fillGradient;
            this.ctx.fill();
        }
        
        // Draw data points (limit for performance)
        const maxPointsToShow = Math.min(this.data.length, 50);
        const pointStep = Math.max(1, Math.floor(this.data.length / maxPointsToShow));
        
        for (let i = 0; i < this.data.length; i += pointStep) {
            const x = this.vertexCache[i * 2];
            const y = this.vertexCache[i * 2 + 1];
            
            // Point glow
            this.ctx.beginPath();
            this.ctx.arc(x, y, 10, 0, Math.PI * 2);
            this.ctx.fillStyle = 'rgba(100,200,255,0.2)';
            this.ctx.fill();
            
            // Point
            this.ctx.beginPath();
            this.ctx.arc(x, y, 6, 0, Math.PI * 2);
            this.ctx.fillStyle = '#4af';
            this.ctx.fill();
            this.ctx.strokeStyle = '#fff';
            this.ctx.lineWidth = 1.5;
            this.ctx.stroke();
            
            // Value label (only show on hover in real implementation)
            if (this.data.length <= 10) { // Show all if few points
                this.ctx.fillStyle = '#8ff';
                this.ctx.font = '11px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`$${this.data[i].value.toFixed(3)}`, x, y - 15);
            }
        }
        
        this.needsRedraw = false;
    }
}

// ============================================================================
// MAIN APPLICATION WITH PERFORMANCE MONITORING
// ============================================================================
class ZSDTracker {
    constructor() {
        // Canvas elements
        this.canvas3d = document.getElementById('canvas3d');
        this.canvasGraph = document.getElementById('canvasGraph');
        this.canvasUI = document.getElementById('canvasUI');
        this.debug = document.getElementById('debug');
        
        // Engines
        this.engine3d = new WebGLTriangleEngine(this.canvas3d);
        this.graphEngine = new HyperOptimizedGraphEngine(this.canvasGraph);
        
        // Performance tracking
        this.fps = 0;
        this.frameCount = 0;
        this.lastFpsUpdate = 0;
        this.lastFrameTime = performance.now();
        this.frameTimeHistory = new Float32Array(60);
        this.frameTimeIndex = 0;
        
        // Data management
        this.dataPoints = [];
        
        // Animation state
        this.isRunning = true;
        this.animationId = 0;
        
        // Performance optimization: adaptive frame rate
        this.targetFPS = 60;
        this.adaptiveFrameSkip = 0;
        
        this.init();
    }
    
    init() {
        this.loadData();
        this.setupEvents();
        this.startAnimation();
    }
    
    loadData() {
        const saved = localStorage.getItem('zsdCurveData');
        if (saved) {
            try {
                const parsed = JSON.parse(saved);
                this.dataPoints = parsed.map(item => ({
                    date: new Date(item.date).getTime(),
                    value: parseFloat(item.value)
                })).sort((a, b) => a.date - b.date);
            } catch (e) {
                this.dataPoints = this.getDefaultData();
            }
        } else {
            this.dataPoints = this.getDefaultData();
        }
        this.graphEngine.setData(this.dataPoints);
        this.updateDataList();
    }
    
    getDefaultData() {
        const now = Date.now();
        const day = 24 * 60 * 60 * 1000;
        return [
            {date: now - day * 3, value: 1.86},
            {date: now - day * 2, value: 1.865},
            {date: now - day * 1, value: 1.87},
            {date: now, value: 1.975}
        ];
    }
    
    saveData() {
        const toSave = this.dataPoints.map(item => ({
            date: new Date(item.date).toISOString(),
            value: item.value
        }));
        localStorage.setItem('zsdCurveData', JSON.stringify(toSave));
        this.updateDataList();
    }
    
    addDataPoint() {
        const dateInput = document.getElementById('dateInput');
        const valueInput = document.getElementById('valueInput');
        
        const date = new Date(dateInput.value).getTime();
        const value = parseFloat(valueInput.value);
        
        if (isNaN(date) || isNaN(value)) return;
        
        // Update existing or add new
        const existingIndex = this.dataPoints.findIndex(d => d.date === date);
        if (existingIndex >= 0) {
            this.dataPoints[existingIndex].value = value;
        } else {
            this.dataPoints.push({date, value});
            this.dataPoints.sort((a, b) => a.date - b.date);
        }
        
        this.graphEngine.setData(this.dataPoints);
        this.saveData();
    }
    
    updateDataList() {
        const list = document.getElementById('dataList');
        list.innerHTML = '';
        
        this.dataPoints.forEach(point => {
            const div = document.createElement('div');
            div.className = 'data-item';
            div.innerHTML = `
                <span class="data-date">${new Date(point.date).toLocaleDateString()}</span>
                <span class="data-value">$${point.value.toFixed(3)}</span>
            `;
            list.appendChild(div);
        });
    }
    
    setupEvents() {
        // Menu toggle
        document.getElementById('menuBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            document.getElementById('controls').classList.toggle('show');
        });
        
        // Close menu when clicking outside
        this.canvasUI.addEventListener('click', () => {
            document.getElementById('controls').classList.remove('show');
        });
        
        // Control buttons
        document.getElementById('addBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            this.addDataPoint();
        });
        
        document.getElementById('saveBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            this.saveData();
        });
        
        document.getElementById('clearBtn').addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('Clear all data?')) {
                this.dataPoints = [];
                localStorage.removeItem('zsdCurveData');
                this.graphEngine.setData(this.dataPoints);
                this.updateDataList();
            }
        });
        
        // Set default date to tomorrow
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        document.getElementById('dateInput').valueAsDate = tomorrow;
        
        // Window resize
        window.addEventListener('resize', () => {
            this.engine3d.resize();
            this.graphEngine.resize();
        });
    }
    
    startAnimation() {
        const animate = (currentTime) => {
            if (!this.isRunning) return;
            
            // Calculate delta time
            const deltaTime = currentTime - this.lastFrameTime;
            this.lastFrameTime = currentTime;
            
            // Track frame time for adaptive performance
            this.frameTimeHistory[this.frameTimeIndex] = deltaTime;
            this.frameTimeIndex = (this.frameTimeIndex + 1) % this.frameTimeHistory.length;
            
            // Update FPS counter
            this.frameCount++;
            if (currentTime - this.lastFpsUpdate >= 1000) {
                this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsUpdate));
                this.frameCount = 0;
                this.lastFpsUpdate = currentTime;
                
                // Adaptive frame skipping based on performance
                if (this.fps < this.targetFPS * 0.9) {
                    this.adaptiveFrameSkip = Math.min(2, this.adaptiveFrameSkip + 1);
                } else if (this.fps > this.targetFPS * 1.1) {
                    this.adaptiveFrameSkip = Math.max(0, this.adaptiveFrameSkip - 1);
                }
                
                this.updateDebugInfo();
            }
            
            // Skip frames if needed for performance
            if (this.frameCount % (this.adaptiveFrameSkip + 1) === 0) {
                // Update and render 3D background
                this.engine3d.update(deltaTime);
                this.engine3d.render();
                
                // Render graph
                this.graphEngine.render();
            }
            
            // Continue animation
            this.animationId = requestAnimationFrame(animate);
        };
        
        this.animationId = requestAnimationFrame(animate);
    }
    
    updateDebugInfo() {
        this.debug.innerHTML = `
            FPS: ${this.fps}<br>
            Points: ${this.dataPoints.length}<br>
            Triangles: ${this.engine3d.triangleCount}<br>
            Quality: ${Math.round(this.engine3d.adaptiveQuality * 100)}%<br>
            Frame Skip: ${this.adaptiveFrameSkip}<br>
            Mem: ${Math.round(performance.memory?.usedJSHeapSize / 1048576) || '?'}MB
        `;
    }
    
    stop() {
        this.isRunning = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
    }
}

// ============================================================================
// INITIALIZATION
// ============================================================================
let app;

window.addEventListener('load', () => {
    app = new ZSDTracker();
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (app) app.stop();
});
</script>
</head>

<body>
<canvas id="canvas3d"></canvas>
<canvas id="canvasGraph"></canvas>
<canvas id="canvasUI"></canvas>

<div id="menuBtn">â‰¡</div>

<div id="controls">
    <div class="control-group">
        <h3>$ZSD TRACKER</h3>
        <label>DATE:</label>
        <input type="date" id="dateInput">
        
        <label>VALUE ($):</label>
        <input type="number" id="valueInput" step="0.001" min="0" value="1.980">
        
        <button id="addBtn">ADD POINT</button>
        <button id="saveBtn">SAVE DATA</button>
        <button id="clearBtn">CLEAR ALL</button>
    </div>
    
    <div class="control-group">
        <h3>DATA POINTS</h3>
        <div id="dataList"></div>
    </div>
</div>

<div id="debug">INITIALIZING...</div>
</body>
</html>
